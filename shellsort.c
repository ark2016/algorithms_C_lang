/*//==============================================================================================================
В классической сортировке втавками для вставки элемента в отсортированную часть последовательности выполняется 
сравнение элемента со всеми членами отсортированной части до тех пор, пока для него не будет найдено место, то есть 
переменная loc (см. алгоритм в лекциях) на каждой итерции внутреннего цикла уменьшается на единицу.

Метод Шелла является модификацией сортировки вставками, в которой переменная loc на каждой итерции внутреннего 
цикла уменьшается на некоторое число d >= 1. При этом фактически сортировка выполняется несколько раз для всё 
меньших и меньших значений d до тех пор, пока d не станет равно 1. Тем самым, сначала выполняется серия «грубых» 
сортировок, которые не дают точного ответа, но делают последовательность более упорядоченной, обеспечивая более 
быстрое выполнение финальной точной сортировки при d = 1.

Составьте функцию shellsort, выполняющую сортировку произвольной последовательности методом Шелла. Функция 
shellsort должна быть объявлена как

void shellsort(unsigned long nel,
        int (*compare)(unsigned long i, unsigned long j),
        void (*swap)(unsigned long i, unsigned long j))
{
        ...
}
Параметры функции shellsort:

nel — количество элементов в последовательности;
compare — указатель на функцию сравнения, которая возвращает 1, если i-й элемент меньше j-го, 0 — в случае, если 
i-й элемент равен j-му, и 1 — в случае, если i-й элемент больше j-го;
swap — указатель на функцию обмена i-то и j-го элементов последовательности.

Значения расстояния d в ходе работы функции должны образовывать последовательность Фибоначчи 
(естественно, записанную задом наперёд). Первое значение в этой последовательности должно быть максимальным 
числом Фибоначчи, которое меньше значения параметра nel.
*///==============================================================================================================
#include <stdio.h>
#include <malloc.h>

#define  MAX_INT_FIB_IDX 47

int *fibInt(int *intArr) {
    intArr = (int *) malloc(MAX_INT_FIB_IDX * sizeof (int));
    intArr[0] = 1;
    intArr[1] = 1;
    for (int i = 2; i < MAX_INT_FIB_IDX; ++i) {
        intArr[i] = intArr[i - 1] + intArr[i - 2];
    }
    return intArr;
}

int nearestFibonacci(int n, int *fibArr){
    int i;
    for(i = 0; i < MAX_INT_FIB_IDX && n < fibArr[i]; ++i);
    return fibArr[i];
}

void shellsort(unsigned long nel, int (*compare)(unsigned long i, unsigned long j),
               void (*swap)(unsigned long i, unsigned long j)) {
    int *fibIntArr = NULL;
    fibIntArr = fibInt(fibIntArr);
    for (int d = nearestFibonacci(nel, fibIntArr); d > 0; d = nearestFibonacci(d - 1, fibIntArr)) {
        for (int i = d; i < nel; ++i) {
            for (int j = i - d; (j >= 0) && (1 == compare(j, j + d)); j -= d) {
                swap(j, j + d);
            }
        }
    }
    free(fibIntArr);
    fibIntArr = NULL;
}
